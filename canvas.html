<html>
  <head>
    <style>
      body {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        width: 100vw;
        height: 100vh;
      }

      h1 {
        font-family: sans-serif;
        letter-spacing: .05em;
        border: 3px solid;
        font-weight: 600;
        padding: 5px 30px;
      }
    </style>
  </head>
  <body>
    <h1>Convex Hull</h1>
    <canvas id="canvas" width="500" height="500"></canvas>
    <script type="module">

      import { edges, convexHull } from './geometry.js';
      import { translate, magnitude, subtract, lerp } from './vec.js';

      // Point [ Int, Int ]
      // Path [ Point ]
      // Edge [ Point, Point ]
      let c = document.getElementById('canvas')
      let ctx = c.getContext('2d');
      let bounds = { w: c.width, h: c.height }
      ctx.strokeWidth = 2;

      c.addEventListener('mousemove', ev => {
        ctx.clearRect(0, 0, 500, 500);
        ctx.textAlign = "center";
        ctx.font = "bold 14px Inter";
        let xPercentage = ev.offsetX / 500;
        ctx.fillText(xPercentage.toFixed(2), ev.offsetX, 480);

        // partial hull
        let shadow = ed.reduce((acc, e) => {

          // While we have a percentage of curve we still need to draw
          if (acc.remaining > 0) {

            // Current Edge
            let edgeLength = magnitude(subtract(e[0], e[1]));

            // Draw the whole edge
            if (edgeLength < acc.remaining) {
              acc.edges.push(e)
              acc.remaining = acc.remaining - edgeLength;
            // Draw a portion of the edge
            } else {
              // Treating the points as two vectors using `lerp`
              let end = lerp((acc.remaining / edgeLength), e[0], e[1]);
              acc.edges.push([e[0], end]);
              acc.remaining = 0;
            }
          }

          return acc;
        }, {
          remaining: xPercentage * hullLength,
          edges: []
        });

        drawEdges(shadow.edges);
      })

      // xs :: [ Edge ]
      const drawEdges = xs => {
        ctx.beginPath();

        xs.forEach(edge => {
          ctx.moveTo( edge[0].x, edge[0].y );
          ctx.lineTo( edge[1].x, edge[1].y );
        });

        ctx.stroke();
      }

      // xs :: Path
      const drawPath = ([ first, ...rest ]) => {
        ctx.beginPath();
        ctx.moveTo( first.x, first.y );
        for (const { x,y } of rest) {
          ctx.lineTo( x, y );
        }
        ctx.stroke();
      }

      // A random 2d point
      const randomPoint = (v) => ({ x: v * Math.random(), y: v * Math.random() });

      // Create out initial point set - constrained to a center square
      const points = Array(500)
                    .fill(450)
                    .map(randomPoint)
                    .map(translate(25))
                    .map(p => ({ x: Math.floor(p.x), y: Math.floor(p.y) }));

      function Draw(){

        return function draw(timestamp) {
          requestAnimationFrame(draw);
            // Draw each point every frame
            for(const { x,y } of points) {
              ctx.fillRect(x, y, 2, 2);
            }
        }
      }

      requestAnimationFrame(Draw());

      // [ Point ] -> [ Edge ]
      const hull = convexHull(points);

      // [ Point ] -> [ Edge ]
      let ed = edges(hull);

      // [ Edge ] -> Number
      let hullLength = ed.reduce((acc, e) => {
        return acc + magnitude(subtract(e[0], e[1]));
      }, 0);

    </script>
  </body>
</html>