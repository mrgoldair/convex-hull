<html>
  <head>
    <style>
      body {
        display: flex;
        justify-content: center;
        align-items: center;
        width: 100vw;
        height: 100vh;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas" width="500" height="500"></canvas>
    <script type="module">

      import { convexHull } from './convex-hull.js';

      // Point [ Int, Int ]
      // Path [ Point ]
      // Edge [ Point, Point ]

      let c = document.getElementById('canvas')
      let ctx = c.getContext('2d');
      let bounds = { w: c.width, h: c.height }
      ctx.strokeWidth = 2;

      c.addEventListener('mousemove', ev => {
        ctx.clearRect(0, 0, 500, 500);
        ctx.textAlign = "center";
        ctx.font = "bold 14px Inter";
        let xPercentage = ev.offsetX / 500;
        ctx.fillText(xPercentage.toFixed(2), ev.offsetX, 480);

        // partial hull
        let shadow = ed.reduce((acc, e) => {

          // While we have a percentage of curve we still need to draw
          if (acc.remaining > 0) {

            // Current Edge
            let edgeLength = magnitude(subtract(e[0], e[1]));

            // Draw the whole edge
            if (edgeLength < acc.remaining) {
              acc.edges.push(e)
              acc.remaining = acc.remaining - edgeLength;
            // Draw a portion of the edge
            } else {
              // Treating the points as two vectors using `lerp`
              let end = lerp((acc.remaining / edgeLength), e[0], e[1]);
              acc.edges.push([e[0], end]);
              acc.remaining = 0;
            }
          }

          return acc;
        }, {
          remaining: xPercentage * hullLength,
          edges: []
        });

        drawEdges(shadow.edges);
      })

      // xs :: [ Point ]
      // type Polygon = Array Point / [ Point ]
      // returns :: [ Edge ]
      const edges = xs => {
        let edges = [];

        for (let edge = 0; edge < (xs.length - 1); edge++) {
          // Take each point and it's subsequent to form an edge
          edges.push([xs[edge], xs[(edge + 1)]]);
        }

        return edges;
      }

      // xs :: [ Edge ]
      const drawEdges = xs => {
        ctx.beginPath();

        xs.forEach(edge => {
          ctx.moveTo( edge[0].x, edge[0].y );
          ctx.lineTo( edge[1].x, edge[1].y );
        });

        ctx.stroke();
      }

      // xs :: Path
      const drawPath = ([ first, ...rest ]) => {
        ctx.beginPath();
        ctx.moveTo( first.x, first.y );
        for (const { x,y } of rest) {
          ctx.lineTo( x, y );
        }
        ctx.stroke();
      }
      
      // Add two vectors
      // Point, Point where Point { x,y }
      const add = (a, b) => {
        return {
          x: a.x + b.x,
          y: a.y + b.y,
          z: a.z + b.z
        }
      }

      // Scalar multiple a point object by `n`
      const scale = (n, { x,y,z }) => ({ x:(x * n), y:(y * n), z:(z * n) });

      // Translate or shift a point object by `n`
      const translate = n => ({ x, y }) => ({ x: (x + n), y: (y + n) });

      // A random 2d point
      const randomPoint = (v) => ({ x: v * Math.random(), y: v * Math.random() });

      // Create out initial point set - constrained to a center square
      const points = Array(500)
                    .fill(450)
                    .map(randomPoint)
                    .map(translate(25))
                    .map(p => ({ x: Math.floor(p.x), y: Math.floor(p.y) }));

      // Subtract one vector from another
      const difference = (v,w) => {
        let diff = {};
        for (const prop in v) {
          diff[prop] = v[prop] - w[prop];
        }
        return diff;
      }
      const subtract = difference;

      // Where `v` is of form { x,y }
      const magnitude = v => {
        let m = 0;
        
        // square and sum each term
        // for (const prop of Object.getOwnPropertyNames(v)){
        //   m += Math.pow(v[prop], 2);
        // }

        // square root sum
        return Math.sqrt( Math.pow(v['x'],2) + Math.pow(v['y'],2) );
      }

      // A vector which retains it's directionality but magnitude is 1
      // -- divide each component by the magnitude of v
      const normalise = v => {
        const m = magnitude(v);
        return v.map(e => e / m);
      }

      // Linearly interpolate between two points
      const lerp = (p, a, b) => {
        return add(scale(1 - p, a), scale(p, b))
      }

      function Draw(){

        return function draw(timestamp) {
          requestAnimationFrame(draw);
            // Draw each point every frame
            for(const { x,y } of points) {
              ctx.fillRect(x, y, 2, 2);
            }
        }
      }

      requestAnimationFrame(Draw());

      // [ Point ] -> [ Edge ]
      const hull = convexHull(points);

      // [ Point ] -> [ Edge ]
      let ed = edges(hull);

      // [ Edge ] -> Number
      let hullLength = ed.reduce((acc, e) => {
        return acc + magnitude(subtract(e[0], e[1]));
      }, 0);

    </script>
  </body>
</html>