<html>
  <head>
    <style>
      body {
        display: flex;
        justify-content: center;
        align-items: center;
        width: 100vw;
        height: 100vh;
      }

      canvas {
        background-color: antiquewhite;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas" width="500" height="500"></canvas>
    <script type="text/javascript" src="/convex-hull.js"></script>
    <script type="text/javascript">

      let c = document.getElementById('canvas')
      let ctx = c.getContext('2d');
      ctx.strokeWidth = 2;
      let bounds = { w: c.width, h: c.height }

      c.addEventListener('mousemove', ev => {
        ctx.clearRect(0, 0, 500, 500);
        ctx.textAlign = "center";
        ctx.font = "bold 14px Inter";
        let xPercentage = ev.offsetX / 500;
        ctx.fillText(xPercentage.toFixed(2), ev.offsetX, 480);

        shadow = ed.reduce((acc, e) => {

          if (acc.remaining > 0) {
            let edgeLength = magnitude(subtract(e[0], e[1]));
            if (edgeLength < acc.remaining) {
              acc.edges.push(e)
              acc.remaining = acc.remaining - edgeLength;
              // console.log("Remaining: %s", acc.remaining);
              // console.log("Edge: %s", edgeLength);
            } else {
              let end = lerp((acc.remaining / edgeLength), e[0], e[1]);
              console.log("Remaining: %s", acc.remaining);
              console.log("Edge: %s", magnitude(subtract(e[0], end)));
              acc.edges.push([e[0], end]);
              acc.remaining = 0;
            }
          }
          // else if (edgeLength == acc.remaining) {
          //     acc.edges.push(e);
          //     acc.remaining = 0;
          //     // console.log("Remaining: %s", acc.remaining);
          //     // console.log("Edge: %s", edgeLength);
          return acc;
        }, {
          remaining: xPercentage * hullLength,
          edges: []
        });

        drawEdges(shadow.edges);
      })

      // `xs` :: Array Point
      // returns :: Array Array Point
      const edges = xs => {
        let edges = [];

        for (let edge = 0; edge < (xs.length - 1); edge++) {
          // Take each point and it's subsequent to form an edge
          edges.push([xs[edge], xs[(edge + 1)]]);
        }

        return edges;
      }

      const distance = path => {
        path.reduce((acc, p) => {
          return {
            d: magnitude(subtract(acc.last,p)),
            last: p
          }
        }, { d:0, last:{ x:0,y:0 } })
      }

      const drawEdges = xs => {
        ctx.beginPath();

        xs.forEach(edge => {
          ctx.moveTo( edge[0].x, edge[0].y );
          ctx.lineTo( edge[1].x, edge[1].y );
        });

        ctx.stroke();
      }

      // Point { x,y }
      // :: Array Point
      const drawPath = ([ first, ...rest ]) => {
        ctx.beginPath();
        ctx.moveTo( first.x, first.y );
        for (const { x,y } of rest) {
          ctx.lineTo( x, y );
        }
        ctx.stroke();
      }
      
      // Add two vectors
      // Point, Point where Point { x,y }
      const add = (a, b) => {
        return {
          x: a.x + b.x,
          y: a.y + b.y,
          z: a.z + b.z
        }
      }

      // Scalar multiple a point object by `n`
      const scale = (n, { x,y,z }) => ({ x:(x * n), y:(y * n), z:(z * n) });

      // Translate or shift a point object by `n`
      const translate = n => ({ x, y }) => ({ x: (x + n), y: (y + n) });

      // A random 2d point
      const randomPoint = (v) => ({ x: v * Math.random(), y: v * Math.random() });

      // Create out initial point set - constrained to a center square
      const points = Array(50)
                    .fill(350)
                    .map(randomPoint)
                    .map(translate(87))
                    .map(p => ({ x: Math.floor(p.x), y: Math.floor(p.y) }));

      // Get last n elements from xs
      const lastN = n => xs => (xs.slice(xs.length - n))

      // Last 1
      const last = lastN(1);

      // Subtract one vector from another
      const difference = (v,w) => {
        let diff = {};
        for (const prop in v) {
          diff[prop] = v[prop] - w[prop];
        }
        return diff;
      }
      const subtract = difference;

      // Where `v` is of form { x,y }
      const magnitude = v => {
        let m = 0;
        
        // square and sum each term
        // for (const prop of Object.getOwnPropertyNames(v)){
        //   m += Math.pow(v[prop], 2);
        // }

        // square root sum
        return Math.sqrt( Math.pow(v['x'],2) + Math.pow(v['y'],2) );
      }

      // A vector which retains it's directionality but magnitude is 1
      // -- divide each component by the magnitude of v
      const normalise = v => {
        const m = magnitude(v);
        return v.map(e => e / m);
      }

      // Linearly interpolate between two points
      const lerp = (p, a, b) => {
        return add(scale(1 - p, a), scale(p, b))
      }

      // a, b, c -- d, e, f
      const cross = (a, b) => {
        return {
          x: a.y * b.z - a.z * b.y,
          y: a.z * b.x - a.x * b.z,
          z: a.x * b.y - a.y * b.x
        };
        // return [
        //   b * f - c * e,
        //   c * d - a * f,
        //   a * e - b * d
        // ];
      }

      //return a * d + b * e + c * f;
      const dot = (a, b) => a.x * b.x + a.y * b.y + a.z * b.z;

      const determinant = (a, b, c) => {
        return dot(cross(a, b), c);
      }

      // Determines if tail of chain makes a left turn
      const leftTurn = (xs) => {
        let [ p, q, r ] = lastN(3)(xs),
            pp = { x:1, y:p.x, z:p.y },
            qq = { x:1, y:q.x, z:q.y },
            rr = { x:1, y:r.x, z:r.y };

        return determinant(pp, qq, rr) <= 0;
      }

      // Removes nth element from tail
      const removeNthFromTail = (n, xs) => {
        // Copy our input array
        let res = Array.from(xs);

        // Splice works in-place
        res.splice(res.length - n, 1);
        return res;
      }

      function Draw(){

        return function draw(timestamp) {
          requestAnimationFrame(draw);
            // Draw each point every frame
            for(const { x,y } of points) {
              ctx.fillRect(x, y, 2, 2);
            }
        }
      }

      requestAnimationFrame(Draw());

      const hull = convexHull(points);
      let ed = edges(hull);
      let hullLength = ed.reduce((acc, e) => {
        return acc + magnitude(subtract(e[0], e[1]));
      }, 0);

    </script>
  </body>
</html>